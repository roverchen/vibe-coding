<!doctype html>
<html lang="zh-Hant">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
    <title>BLE 按鈕控制 (Mobile)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 確保全螢幕高度和柔軟的背景色 */
        body { 
            background-color: #1f2937; 
            color: #f9fafb; 
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0; 
            padding: 1rem;
        }
        .container-wrap { 
            max-width: 400px; 
            width: 100%; 
            padding: 20px; 
            background-color: #1f2937; /* 與 body 背景一致 */
            border-radius: 1rem;
        }
        
        /* 頂部控制列 */
        .top{width:100%;display:flex;gap:8px;align-items:center; max-width: 520px; margin-bottom: 20px;}
        button{padding:10px 14px;border-radius:12px;border:none;background:#4f46e5;color:white;font-weight:700;box-shadow: 3px 3px 6px #1a202c, -3px -3px 6px #273142; transition: all 0.15s ease-in-out; cursor: pointer;}
        button:hover { background: #3730a3; box-shadow: 5px 5px 10px #1a202c, -5px -5px 10px #273142;}
        button:active { background: #3730a3; box-shadow: inset 3px 3px 6px #1a202c, inset -3px -3px 6px #273142;}

        #status{flex:1;text-align:center;font-weight:700;color:#f9fafb; padding: 10px; background: #2d3748; border-radius: 12px; box-shadow: inset 3px 3px 6px #1a202c, inset -3px -3px 6px #273142;}

        /* 狀態文字 */
        #main-status { font-weight: 700; text-shadow: 0 0 5px rgba(79, 70, 229, 0.5); }
        .info{font-size:14px;color:#9ca3af; margin-top: 20px;}

        /* 替換搖桿的按鈕區域樣式 */
        .control-pad {
            display: grid;
            grid-template-areas: ". forward ." "left . right" ". backward .";
            gap: 10px;
            width: 100%;
            max-width: 300px; /* 限制寬度使其看起來像一個控制區 */
            margin: 20px auto;
        }
        .control-pad button {
            padding: 20px 0; /* 讓按鈕大一點 */
            font-size: 18px;
            min-width: 80px;
        }
        #btnForward { grid-area: forward; }
        #btnBackward { grid-area: backward; }
        #btnLeft { grid-area: left; }
        #btnRight { grid-area: right; }

    </style>
</head>
<body class="p-4">
    <div class="container-wrap">
        
        <h1 class="text-3xl font-extrabold text-center text-indigo-400 mb-6">BLE 按鈕控制</h1>

        <div class="top">
            <button id="btnConnect">連線 BLE</button>
            <div id="status">未連線</div>
        </div>

        <div class="control-pad">
            <button id="btnForward">前進</button>
            <button id="btnLeft">左轉</button>
            <button id="btnRight">右轉</button>
            <button id="btnBackward">後退</button>
        </div>

        <div class="text-center space-y-2">
            <p class="text-xl">狀態: <span id="main-status" class="text-green-400">靜止</span></p>
            <p class="text-xs text-gray-500">
                T (速度): <span id="val_t">0</span> | S (轉向): <span id="val_s">0</span>
            </p>
        </div>
    </div>

<script>
// --- BLE & Control Configuration (保持不變) ---
const SERVICE_UUID = '4fafc201-1fb5-459e-8fcc-000000000000'; 
const CHARACTERISTIC_UUID = '4fafc201-1fb5-459e-8fcc-000000000000'; 
const DEVICE_ID_KEY = 'ble_joystick_device_id'; 
const MAX_CONTROL_VALUE = 255; 
// 搖桿 Deadzone 不再需要

// --- DOM Elements ---
// 移除搖桿相關元素
const statusEl = document.getElementById('status'); 
const mainStatusEl = document.getElementById('main-status'); 
const valTEl = document.getElementById('val_t'); 
const valSEl = document.getElementById('val_s'); 
const btnConnect = document.getElementById('btnConnect');

// 新增方向按鈕元素
const btnForward = document.getElementById('btnForward');
const btnBackward = document.getElementById('btnBackward');
const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');


// --- State Variables ---
let device = null;
let characteristic = null;
let sendingInterval = null;
let lastPayload = {t: 0, s: 0}; // 儲存上次發送的整數 T, S 值


// --- Helper Functions (簡化) ---

/**
 * 更新馬達控制值並更新 UI 顯示
 * @param {number} speedT 速度 T (-255 到 255)
 * @param {number} speedS 轉向 S (-255 到 255)
 */
function updateMotorValues(speedT, speedS) {
    
    // 更新 UI 顯示 (整數值)
    valTEl.textContent = speedT; 
    valSEl.textContent = speedS; 
    
    // 更新狀態文字和顏色
    let currentStatus = "靜止";
    let statusColor = "text-green-400";
    if (speedT > 0 && speedS === 0) {
        currentStatus = "前進加速中";
        statusColor = "text-yellow-400";
    } else if (speedT < 0 && speedS === 0) {
        currentStatus = "後退減速中";
        statusColor = "text-yellow-400";
    } else if (speedS > 0 && speedT === 0) {
        currentStatus = "右轉中";
        statusColor = "text-yellow-400";
    } else if (speedS < 0 && speedT === 0) {
        currentStatus = "左轉中";
        statusColor = "text-yellow-400";
    } else if (speedT === 0 && speedS === 0) {
        currentStatus = "靜止";
        statusColor = "text-green-400";
    } else {
        // 處理多個按鈕同時按下的情況 (例如 前進 + 左轉)
        currentStatus = "組合移動中";
        statusColor = "text-yellow-400";
    }
    mainStatusEl.textContent = currentStatus;
    mainStatusEl.className = `font-bold ${statusColor}`;

    // 儲存最新的整數值，供 sendControl 定期發送
    lastPayload.t = speedT;
    lastPayload.s = speedS;
}

function stopMotors() {
    if (sendingInterval) clearInterval(sendingInterval);
    sendingInterval = null;
    // 立即發送 T=0, S=0 停止命令
    updateMotorValues(0, 0); 
    sendControl(); // 確保立即發送一次停止指令
}


/**
 * @brief 按下按鈕時啟動移動
 * @param {number} t 目標 T 值
 * @param {number} s 目標 S 值
 */
function handleStartMove(t, s) {
    // 設置目標值
    updateMotorValues(t, s);
    
    // 如果沒有在定期發送，則開始定期傳送
    if (!sendingInterval) {
        sendingInterval = setInterval(sendControl, 60); // 每 60ms
    }
}

/**
 * @brief 釋放按鈕時停止移動
 */
function handleStopMove() {
    // 如果沒有其他按鈕被按住，則停止馬達
    // 由於我們無法直接判斷多個按鈕是否同時被按住，最簡單的策略是：
    // 任何釋放事件都發送 T=0, S=0，或者，僅在沒有活動按鈕時停止。
    // 在這裡，我們採用一個簡化的方法：只在非連線狀態下停止。
    // 為了實現 "多按鈕" 邏輯，我們將監聽 'touchstart' 和 'touchend' 來判斷是否有按鈕被按住
    
    // 為了單獨控制，現在只將按鈕值設為 0
    updateMotorValues(0, 0);
    stopMotors(); // 確保立即停止
}


// --- Button Event Listeners ---

// 為了支援手機上的連續按壓 (touch and hold)，使用 'touchstart'/'touchend' 或 'pointerdown'/'pointerup'

// 前進
btnForward.addEventListener('pointerdown', () => handleStartMove(MAX_CONTROL_VALUE, 0));
btnForward.addEventListener('pointerup', stopMotors); 
btnForward.addEventListener('mouseleave', stopMotors); // 滑鼠離開也停止

// 後退
btnBackward.addEventListener('pointerdown', () => handleStartMove(-MAX_CONTROL_VALUE, 0));
btnBackward.addEventListener('pointerup', stopMotors);
btnBackward.addEventListener('mouseleave', stopMotors);

// 左轉
btnLeft.addEventListener('pointerdown', () => handleStartMove(0, -MAX_CONTROL_VALUE));
btnLeft.addEventListener('pointerup', stopMotors);
btnLeft.addEventListener('mouseleave', stopMotors);

// 右轉
btnRight.addEventListener('pointerdown', () => handleStartMove(0, MAX_CONTROL_VALUE));
btnRight.addEventListener('pointerup', stopMotors);
btnRight.addEventListener('mouseleave', stopMotors);

// 額外處理觸控事件 (確保在手機上釋放時停止)
[btnForward, btnBackward, btnLeft, btnRight].forEach(btn => {
    btn.addEventListener('touchend', stopMotors);
    btn.addEventListener('touchcancel', stopMotors);
});


// --- BLE Connection Logic (保持不變，但移除 isDragging 相關邏輯) ---

/**
 * 處理 BLE 斷線
 */
function onDisconnect() {
    statusEl.textContent = '❌ 已斷線';
    btnConnect.textContent = '連線 BLE'; // 斷線後改回連線
    stopMotors(); // 斷線時停止馬達
    if (device) device.removeEventListener('gattserverdisconnected', onDisconnect);
    device = null;
    characteristic = null;
}

/**
 * 取得裝置物件 (透過掃描或快速重連)
 */
async function acquireDevice() {
    const storedDeviceId = localStorage.getItem(DEVICE_ID_KEY);

    if (storedDeviceId) {
        statusEl.textContent = '嘗試使用 ID 快速連線...';
        try {
            const devices = await navigator.bluetooth.getDevices();
            const knownDevice = devices.find(d => d.id === storedDeviceId);

            if (knownDevice) {
                 statusEl.textContent = `已找到儲存的裝置: ${knownDevice.name}`;
                 return knownDevice;
            }
        } catch (e) {
            console.warn("Could not retrieve known device:", e);
        }
    }
    
    statusEl.textContent = '掃描中 (過濾: esp32)...';
    const newDevice = await navigator.bluetooth.requestDevice({
        filters:[{ namePrefix: 'esp32' }],
        optionalServices: [SERVICE_UUID] 
    });
    
    localStorage.setItem(DEVICE_ID_KEY, newDevice.id);
    return newDevice;
}


async function connectBLE(){
    if (!navigator.bluetooth) {
        statusEl.textContent = '❌ 瀏覽器不支援 Web Bluetooth。';
        return;
    }
    
    // 處理已連線狀態下的按鈕點擊 (斷開連線)
    if (device && device.gatt.connected) {
        statusEl.textContent = '中斷連線中...';
        device.gatt.disconnect();
        // onDisconnect 會處理 UI 狀態更新
        return;
    }

    try{
        if (!device) {
             device = await acquireDevice();
        } 
        
        if (!device) throw new Error("裝置未連線或未找到。");

        statusEl.textContent = `連線到 ${device.name}...`;

        device.removeEventListener('gattserverdisconnected', onDisconnect);
        device.addEventListener('gattserverdisconnected', onDisconnect);

        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        // 使用修正後的 CHARACTERISTIC_UUID
        characteristic = await service.getCharacteristic(CHARACTERISTIC_UUID); 
        
        statusEl.textContent = '✅ 已連線: ' + device.name;
        // 連線成功，將按鈕文字改為「斷開」
        btnConnect.textContent = '斷開'; 

        // 如果連線成功，且有按鈕被按住，則在 handleStartMove 中會自動啟動傳送

    }catch(err){
        console.error('BLE 連線失敗:', err);
        statusEl.textContent = `❌ 連線失敗 (${err.message.slice(0, 30)}...)`;
        btnConnect.textContent = '連線 BLE';
        clearInterval(sendingInterval);
        sendingInterval = null;
        
        if (device && (!device.gatt || !device.gatt.connected)) {
            device = null;
            localStorage.removeItem(DEVICE_ID_KEY);
        }
    }
}


/**
 * 定期向 ESP32 傳送控制指令
 */
async function sendControl(){
  if(!characteristic || !device || !device.gatt.connected) {
    if (sendingInterval) clearInterval(sendingInterval);
    sendingInterval = null;
    return;
  }
  
  // 使用 lastPayload 中儲存的整數值
  const t_int = lastPayload.t;
  const s_int = lastPayload.s;
  
  // 建立 payload 格式: T,S (例如: "255,0")
  const payload = `${t_int},${s_int}`;
  
  try{
    await characteristic.writeValue(new TextEncoder().encode(payload));
  }catch(err){
    console.warn('send failed (可能已斷線):', err.message);
  }
}

// --- Initialization ---

btnConnect.addEventListener('click', connectBLE);
stopMotors(); // 確保初始狀態為靜止
</script>
</body>
</html>