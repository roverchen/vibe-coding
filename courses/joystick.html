<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>BLE 搖桿控制 (Mobile)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* 確保全螢幕高度和柔軟的背景色 */
    body { 
        background-color: #1f2937; 
        color: #f9fafb; 
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        display: flex; 
        justify-content: center; 
        align-items: center; 
        min-height: 100vh; 
        margin: 0; 
        padding: 1rem;
    }
    .container-wrap { 
        max-width: 400px; 
        width: 100%; 
        padding: 20px; 
        background-color: #1f2937; /* 與 body 背景一致 */
        border-radius: 1rem;
    }
    /* 搖桿圓盤樣式 (pad/joystick) */
    #joystick { 
        position: relative; 
        width: 100%;
        padding-top: 100%; /* 1:1 比例 */
        margin: 0 auto; 
        border-radius: 50%; 
        background: linear-gradient(145deg, #2d3748, #1a202c); 
        box-shadow: 10px 10px 20px #171d26, -10px -10px 20px #273142, inset 0 0 10px rgba(0,0,0,0.5);
        touch-action: none; /* 禁用瀏覽器預設的觸摸行為 */
    }
    /* 實際可拖曳區域 (joystick-inner) */
    #joystick-inner {
        position: absolute;
        top: 5%; left: 5%; right: 5%; bottom: 5%;
        width: 90%;
        height: 90%;
    }
    /* 搖桿中心點 (Thumb/stick) */
    #joystick-thumb {
        position: absolute;
        width: 70px; 
        height: 70px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        background: #4f46e5;
        box-shadow: 0 0 15px #4f46e5, inset 0 0 10px #7c3aed;
        cursor: grab;
        transition: box-shadow 0.1s;
        display: flex; /* 新增，用於顯示數值 */
        align-items: center;
        justify-content: center;
        font-size: 10px;
        color: #f9fafb;
        font-weight: bold;
    }
    #joystick-thumb.active { cursor: grabbing; box-shadow: 0 0 25px #7c3aed, inset 0 0 15px #4f46e5; }
    
    /* 頂部控制列 */
    .top{width:100%;display:flex;gap:8px;align-items:center; max-width: 520px; margin-bottom: 20px;}
    button{padding:10px 14px;border-radius:12px;border:none;background:#4f46e5;color:white;font-weight:700;box-shadow: 3px 3px 6px #1a202c, -3px -3px 6px #273142; transition: all 0.15s ease-in-out;}
    button:hover { background: #3730a3; box-shadow: 5px 5px 10px #1a202c, -5px -5px 10px #273142;}
    
    #status{flex:1;text-align:center;font-weight:700;color:#f9fafb; padding: 10px; background: #2d3748; border-radius: 12px; box-shadow: inset 3px 3px 6px #1a202c, inset -3px -3px 6px #273142;}

    /* 狀態文字 */
    #main-status { font-weight: 700; text-shadow: 0 0 5px rgba(79, 70, 229, 0.5); }
    .info{font-size:14px;color:#9ca3af; margin-top: 20px;}
  </style>
</head>
<body class="p-4">
    <div class="container-wrap">
        
        <h1 class="text-3xl font-extrabold text-center text-indigo-400 mb-6">BLE 搖桿控制</h1>

        <div class="top">
            <!-- 按鈕文字會根據連線狀態切換 -->
            <button id="btnConnect">連線 BLE</button>
            <div id="status">未連線</div>
        </div>

        <div id="joystick" class="mb-6">
            <div id="joystick-inner">
                 <div id="joystick-thumb">0,0</div>
            </div>
        </div>

        <div class="text-center space-y-2">
            <p class="text-xl">狀態: <span id="main-status" class="text-green-400">靜止</span></p>
            <p class="text-xs text-gray-500">
                T (速度): <span id="val_t">0</span> | S (轉向): <span id="val_s">0</span>
            </p>
        </div>
    </div>

<script>
// --- BLE & Control Configuration ---
// 1. SERVICE_UUID 保持不變
const SERVICE_UUID = '4fafc201-1fb5-459e-8fcc-000000000000'; 
// 2. CHARACTERISTIC_UUID 修正為與 SERVICE_UUID 相同
const CHARACTERISTIC_UUID = '4fafc201-1fb5-459e-8fcc-000000000000'; 
const DEVICE_ID_KEY = 'ble_joystick_device_id'; 
const MAX_CONTROL_VALUE = 255; 
// 搖桿 Deadzone (控制值 T/S 的絕對值小於此值時設為 0)
const DEADZONE_PWM = 20; 

// --- DOM Elements ---
const joystickContainer = document.getElementById('joystick');
const joystickInner = document.getElementById('joystick-inner');
const thumb = document.getElementById('joystick-thumb');
const statusEl = document.getElementById('status'); // BLE 連線狀態
const mainStatusEl = document.getElementById('main-status'); // 搖桿狀態
const valTEl = document.getElementById('val_t'); // T (Throttle)
const valSEl = document.getElementById('val_s'); // S (Steer)
const btnConnect = document.getElementById('btnConnect');

// --- State Variables ---
let device = null;
let characteristic = null;
let sendingInterval = null;
let lastPayload = {t: 0, s: 0}; // 儲存上次發送的整數 T, S 值
let isDragging = false;

// --- Joystick Dimensions ---
let rect, centerX, centerY, maxRadius;


// --- Helper Functions ---

/**
 * 重新計算搖桿區域的尺寸和中心點
 */
function resize() {
    rect = joystickInner.getBoundingClientRect();
    // 中心點座標 (相對於整個視窗)
    centerX = rect.left + rect.width / 2;
    centerY = rect.top + rect.height / 2;
    // 最大移動半徑設定為搖桿區域半徑
    maxRadius = rect.width / 2;
}

window.addEventListener('resize', resize);
resize();

function clamp(v,min,max){return Math.max(min,Math.min(max,v));}


/**
 * @brief 根據搖桿位置 (Cartesian 座標) 計算並更新整數馬達速度。
 * @param {number} rawX 搖桿相對於中心的 X 位移 (像素)
 * @param {number} rawY 搖桿相對於中心的 Y 位移 (像素, 向上為正)
 */
function updateMotorValues(rawX, rawY) {
    
    // 1. 計算幅度 (magnitude)
    const distance = Math.sqrt(rawX*rawX + rawY*rawY);
    // 確保幅度在 0.0 到 1.0 之間
    const magnitude = Math.min(1.0, distance / maxRadius);
    const angle = Math.atan2(rawY, rawX);
    
    // 2. 計算歸一化後的 X, Y (範圍 -1.0 到 1.0)
    const normS = magnitude * Math.cos(angle); // 轉向 (Steering, X 軸)
    const normT = magnitude * Math.sin(angle); // 速度 (Throttle, Y 軸)

    // 3. 轉換為 -255 到 255 的整數 (四捨五入)
    let speedT = Math.round(normT * MAX_CONTROL_VALUE);
    let speedS = Math.round(normS * MAX_CONTROL_VALUE);

    // --- 4. 實作 Deadzone 邏輯 ---
    if (Math.abs(speedT) < DEADZONE_PWM) {
        speedT = 0;
    }
    if (Math.abs(speedS) < DEADZONE_PWM) {
        speedS = 0;
    }
    // ----------------------------------------------------

    // 更新 UI 顯示 (整數值)
    valTEl.textContent = speedT; 
    valSEl.textContent = speedS; 
    thumb.textContent = `${speedT},${speedS}`;
    
    // 更新狀態文字和顏色
    let currentStatus = "靜止";
    let statusColor = "text-green-400";
    if (Math.abs(speedT) > 0 || Math.abs(speedS) > 0) {
         statusColor = "text-yellow-400";
         if (speedT > DEADZONE_PWM && Math.abs(speedS) < DEADZONE_PWM) currentStatus = "前進加速中";
         else if (speedT < -DEADZONE_PWM && Math.abs(speedS) < DEADZONE_PWM) currentStatus = "後退減速中";
         else if (speedS > DEADZONE_PWM) currentStatus = "右轉中";
         else if (speedS < -DEADZONE_PWM) currentStatus = "左轉中";
         else currentStatus = "移動中";
    } else {
         statusColor = "text-green-400";
    }
    mainStatusEl.textContent = currentStatus;
    mainStatusEl.className = `font-bold ${statusColor}`;

    // 儲存最新的整數值，供 sendControl 定期發送
    lastPayload.t = speedT;
    lastPayload.s = speedS;
}


// --- Joystick Event Handlers ---

function resetThumbPosition() {
    thumb.style.left = '50%';
    thumb.style.top = '50%';
    thumb.style.transform = 'translate(-50%, -50%)';
    thumb.classList.remove('active');
}

function stopMotors() {
    isDragging = false;
    if (sendingInterval) clearInterval(sendingInterval);
    sendingInterval = null;
    resetThumbPosition();
    // 立即發送 T=0, S=0 停止命令
    updateMotorValues(0, 0); 
}

function handleMove(e) {
    e.preventDefault();
    if (!isDragging) return;

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    const rect = joystickInner.getBoundingClientRect();
    const centerX = rect.left + maxRadius;
    const centerY = rect.top + maxRadius;

    let offsetX = clientX - centerX;
    let offsetY = clientY - centerY; 
    
    // 限制位移在搖桿圓盤內
    const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
    if (distance > maxRadius) {
        const angle = Math.atan2(offsetY, offsetX);
        offsetX = maxRadius * Math.cos(angle);
        offsetY = maxRadius * Math.sin(angle);
    }
    
    // 更新搖桿中心點位置 (CSS 座標)
    const thumbX = maxRadius + offsetX;
    const thumbY = maxRadius + offsetY; 

    thumb.style.left = `${thumbX}px`;
    thumb.style.top = `${thumbY}px`;
    thumb.style.transform = 'translate(-50%, -50%)';

    // 更新馬達值 (Cartesian 座標: Y 軸向上為正, 所以要反轉 offsetY)
    updateMotorValues(offsetX, -offsetY);
}

function handleStart(e) {
    isDragging = true;
    thumb.classList.add('active');
    handleMove(e); // 立即更新一次位置和值

    // 開始定期傳送 (保持命令持續性)
    if (!sendingInterval) {
         sendingInterval = setInterval(sendControl, 60); // 每 60ms
    }
}

function handleEnd() {
    // 停止馬達並清除間隔發送器 (sendControl 會在 interval 中停止，這裡先停止 interval)
    stopMotors(); 
}

// --- Joystick Event Listeners ---

joystickInner.addEventListener('pointerdown', handleStart);
document.addEventListener('pointermove', handleMove);
document.addEventListener('pointerup', handleEnd);

// 確保觸摸事件也能被正確處理 (Pointer Events 覆蓋了大部分 Touch 和 Mouse)
joystickInner.addEventListener('touchcancel', handleEnd);


// --- BLE Connection Logic (Retained from previous version) ---

/**
 * 處理 BLE 斷線
 * 3. 處理斷線後，將按鈕文字改回「連線 BLE」
 */
function onDisconnect() {
    statusEl.textContent = '❌ 已斷線';
    btnConnect.textContent = '連線 BLE'; // 斷線後改回連線
    if (sendingInterval) clearInterval(sendingInterval);
    sendingInterval = null;
    stopMotors(); // 斷線時停止馬達
    if (device) device.removeEventListener('gattserverdisconnected', onDisconnect);
    device = null;
    characteristic = null;
}

/**
 * 取得裝置物件 (透過掃描或快速重連)
 */
async function acquireDevice() {
    const storedDeviceId = localStorage.getItem(DEVICE_ID_KEY);

    if (storedDeviceId) {
        statusEl.textContent = '嘗試使用 ID 快速連線...';
        try {
            const devices = await navigator.bluetooth.getDevices();
            const knownDevice = devices.find(d => d.id === storedDeviceId);

            if (knownDevice) {
                 statusEl.textContent = `已找到儲存的裝置: ${knownDevice.name}`;
                 return knownDevice;
            }
        } catch (e) {
            console.warn("Could not retrieve known device:", e);
        }
    }
    
    statusEl.textContent = '掃描中 (過濾: esp32)...';
    // 注意: 由於 CHARACTERISTIC_UUID 已被修改，這裡必須確保 SERVICE_UUID 是正確的。
    const newDevice = await navigator.bluetooth.requestDevice({
        filters:[{ namePrefix: 'esp32' }],
        optionalServices: [SERVICE_UUID] 
    });
    
    localStorage.setItem(DEVICE_ID_KEY, newDevice.id);
    return newDevice;
}


async function connectBLE(){
    if (!navigator.bluetooth) {
        statusEl.textContent = '❌ 瀏覽器不支援 Web Bluetooth。';
        return;
    }
    
    // 3. 處理已連線狀態下的按鈕點擊 (斷開連線)
    if (device && device.gatt.connected) {
        statusEl.textContent = '中斷連線中...';
        device.gatt.disconnect();
        // onDisconnect 會處理 UI 狀態更新
        return;
    }

    try{
        if (!device) {
             device = await acquireDevice();
        } 
        
        if (!device) throw new Error("裝置未連線或未找到。");

        statusEl.textContent = `連線到 ${device.name}...`;

        device.removeEventListener('gattserverdisconnected', onDisconnect);
        device.addEventListener('gattserverdisconnected', onDisconnect);

        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        // 使用修正後的 CHARACTERISTIC_UUID
        characteristic = await service.getCharacteristic(CHARACTERISTIC_UUID); 
        
        statusEl.textContent = '✅ 已連線: ' + device.name;
        // 3. 連線成功，將按鈕文字改為「斷開」
        btnConnect.textContent = '斷開'; 

        // 如果搖桿正在拖曳，則開始傳送
        if(isDragging && !sendingInterval) {
            sendingInterval = setInterval(sendControl, 60);
        }

    }catch(err){
        console.error('BLE 連線失敗:', err);
        statusEl.textContent = `❌ 連線失敗 (${err.message.slice(0, 30)}...)`;
        btnConnect.textContent = '連線 BLE';
        clearInterval(sendingInterval);
        sendingInterval = null;
        
        if (device && (!device.gatt || !device.gatt.connected)) {
            device = null;
            localStorage.removeItem(DEVICE_ID_KEY);
        }
    }
}


/**
 * 定期向 ESP32 傳送控制指令
 * Payload 格式：整數 "T,S" 字串
 */
async function sendControl(){
  if(!characteristic || !device || !device.gatt.connected) {
    if (sendingInterval) clearInterval(sendingInterval);
    sendingInterval = null;
    return;
  }
  
  // 使用 lastPayload 中儲存的整數值 (已包含 Deadzone 處理)
  const t_int = lastPayload.t;
  const s_int = lastPayload.s;
  
  // 建立 payload 格式: T,S (例如: "200,0")
  const payload = `${t_int},${s_int}`;
  
  try{
    await characteristic.writeValue(new TextEncoder().encode(payload));
  }catch(err){
    console.warn('send failed (可能已斷線):', err.message);
  }
}

// --- Initialization ---

btnConnect.addEventListener('click', connectBLE);
stopMotors(); // 確保初始狀態為靜止
</script>
</body>
</html>