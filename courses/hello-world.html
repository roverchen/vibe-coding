<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Gemini TTS 笑臉按鈕 (最終 iOS 優化)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* 核心深色主題樣式 */
    body { 
        background-color: #1f2937; 
        color: #f9fafb; 
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        display: flex; 
        justify-content: center; 
        align-items: center; 
        min-height: 100vh; 
        margin: 0; 
        padding: 1rem;
    }
    .container-wrap { 
        max-width: 450px; 
        width: 100%; 
        padding: 30px; 
        background-color: #1f2937;
        border-radius: 1.5rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
    }

    /* 笑臉按鈕容器樣式 (Neumorphic 外凸效果) */
    #smileButton {
        width: 250px;
        height: 250px;
        margin: 0 auto 30px auto; 
        border-radius: 50%;
        cursor: pointer;
        background: #374151;
        /* 外凸陰影 */
        box-shadow: 
            8px 8px 16px #1a222c, 
            -8px -8px 16px #3b4555;
        transition: all 0.2s ease;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        touch-action: manipulation;
    }

    /* 按下/啟用時的內凹效果 */
    #smileButton:active, #smileButton.active {
        background: #232d3a;
        /* 內凹陰影 */
        box-shadow: 
            inset 5px 5px 10px #1a222c, 
            inset -5px -5px 10px #3b4555;
        transform: scale(0.98);
    }
    
    /* 內嵌 SVG 笑臉的顏色 */
    .face-svg {
        width: 80%;
        height: 80%;
    }
    
    /* 載入指示器 */
    #loadingSpinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50px;
        height: 50px;
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid #fcd34d;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.3s;
    }
    
    #loadingSpinner.visible {
        opacity: 1;
    }

    @keyframes spin {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        100% { transform: translate(-50%, -50%) rotate(360deg); }
    }


    /* 狀態顯示區域 - 預設字體稍微小一點 (1.25rem)，用於語音訊息等 */
    #statusDisplay{
        min-height: 3rem;
        width: 90%;
        padding: 12px; 
        margin: 0 0 30px 0; 
        background: transparent; 
        border-radius: 12px; 
        font-size: 1.25rem; 
        font-weight: 700;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: color 0.5s ease, font-size 0.3s ease;
    }
    
    /* Hello World 初始狀態 - 字體變大 */
    #statusDisplay.initial-status {
        font-size: 2rem;
    }


    /* 返回主選單按鈕 */
    .menu-button {
        display: block;
        width: 90%;
        padding: 12px;
        margin-top: 30px;
        border-radius: 12px;
        border: none;
        background: #4f46e5; 
        color: white;
        font-weight: 700;
        text-align: center;
        text-decoration: none;
        box-shadow: 3px 3px 6px #171d26, -3px -3px 6px #273142;
        transition: all 0.2s ease;
    }
    .menu-button:hover {
        background: #3730a3; 
        box-shadow: 5px 5px 10px #171d26, -5px -5px 10px #273142;
    }
    
    /* 禁用狀態的笑臉按鈕 (在載入音訊時) */
    #smileButton.disabled {
        cursor: not-allowed;
        opacity: 0.7;
    }

  </style>
</head>
<body class="p-4">
    <div class="container-wrap">
        
        <!-- 狀態顯示區 - 移到最上方 -->
        <div id="statusDisplay" class="initial-status">
            <!-- 初始內容將由 JavaScript 設定 -->
        </div>

        <!-- 笑臉按鈕 -->
        <div id="smileButton" role="button" aria-label="Say Hello">
            <!-- SVG 笑臉圖形 -->
            <svg class="face-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <!-- 臉部圓形 (黃色) -->
                <circle cx="50" cy="50" r="48" fill="#FFDA00"/>
                <!-- 左眼 (黑色) -->
                <circle cx="35" cy="35" r="8" fill="#000"/>
                <!-- 右眼 (黑色) -->
                <circle cx="65" cy="35" r="8" fill="#000"/>
                <!-- 嘴巴 (黑色) -->
                <path d="M 25 65 Q 50 85, 75 65" fill="none" stroke="#000" stroke-width="5" stroke-linecap="round"/>
            </svg>
            <!-- 載入指示器 -->
            <div id="loadingSpinner"></div>
        </div>

        
        <!-- 返回主選單按鈕 -->
        <a href="index.html" class="menu-button">
            返回主選單
        </a>
    </div>

<script>
    // ========================================================================
    // DOM Elements & Configuration
    // ========================================================================
    const smileButton = document.getElementById('smileButton');
    const statusDisplay = document.getElementById('statusDisplay');
    const loadingSpinner = document.getElementById('loadingSpinner');
    
    // API Configurations
    const API_URL_BASE = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent';
    const API_KEY = ""; 

    // Status Texts
    const CLICK_PHRASE = "你好啊！歡迎來到 Vibe Coding 的世界，課程即將開始。"; 
    const INITIAL_PHRASE = "Hello World"; 
    
    // Voice Configuration
    const VOICE_NAME = "Kore"; 

    let statusTimeout;
    let isSpeaking = false; 
    let audioContext = null; 

    // ========================================================================
    // Audio Utility Functions
    // ========================================================================

    /**
     * 初始化或返回單例 AudioContext
     * @returns {AudioContext} 
     */
    function getAudioContext() {
        if (!audioContext) {
            // 處理跨瀏覽器前綴
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            if (AudioContextClass) {
                audioContext = new AudioContextClass();
            } else {
                console.error("此瀏覽器不支持 Web Audio API。");
                return null;
            }
        }
        return audioContext;
    }

    /**
     * Helper function: Converts a Base64 string to an ArrayBuffer.
     * @param {string} base64 base64 encoded string
     * @returns {ArrayBuffer} 
     */
    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }
    
    /**
     * [關鍵改動] Helper function: Converts a Blob to an ArrayBuffer using Promise/Await.
     * 避免使用 FileReader.onload 異步回呼，保持與點擊事件的同步性。
     * @param {Blob} blob 
     * @returns {Promise<ArrayBuffer>} 
     */
    function blobToArrayBuffer(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = (error) => reject(new Error("FileReader 讀取失敗: " + error.target.error));
            reader.readAsArrayBuffer(blob);
        });
    }

    /**
     * Helper function: Converts PCM 16-bit audio data into a WAV Blob.
     * @param {Int16Array} pcm16 16-bit signed PCM data
     * @param {number} sampleRate Sample rate (e.g., 24000)
     * @returns {Blob} WAV format audio Blob
     */
    function pcmToWav(pcm16, sampleRate) {
        const numChannels = 1;
        const bitsPerSample = 16;
        const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
        const blockAlign = numChannels * (bitsPerSample / 8);
        const dataLength = pcm16.length * (bitsPerSample / 8);
        const buffer = new ArrayBuffer(44 + dataLength);
        const view = new DataView(buffer);
        let offset = 0;

        /* Helper to write string to DataView */
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        /* 1. RIFF Chunk */
        writeString(view, offset, 'RIFF'); offset += 4;
        view.setUint32(offset, 36 + dataLength, true); offset += 4;
        writeString(view, offset, 'WAVE'); offset += 4;

        /* 2. fmt Chunk (Format) */
        writeString(view, offset, 'fmt '); offset += 4;
        view.setUint32(offset, 16, true); offset += 4;
        view.setUint16(offset, 1, true); offset += 2;
        view.setUint16(offset, numChannels, true); offset += 2;
        view.setUint32(offset, sampleRate, true); offset += 4;
        view.setUint32(offset, byteRate, true); offset += 4;
        view.setUint16(offset, blockAlign, true); offset += 2;
        view.setUint16(offset, bitsPerSample, true); offset += 2;

        /* 3. data Chunk */
        writeString(view, offset, 'data'); offset += 4;
        view.setUint32(offset, dataLength, true); offset += 4;

        /* Write PCM data (Int16) */
        for (let i = 0; i < pcm16.length; i++) {
            view.setInt16(offset + i * 2, pcm16[i], true);
        }

        return new Blob([buffer], { type: 'audio/wav' });
    }

    // ========================================================================
    // TTS Logic and Playback (Fully Awaited for iOS)
    // ========================================================================

    /**
     * Generates and plays audio using the Gemini TTS API.
     * @param {string} text The text to synthesize.
     * @param {AudioContext} activeAudioContext - 來自點擊事件中已恢復狀態的 AudioContext
     */
    async function speakText(text, activeAudioContext) {
        if (isSpeaking) return;

        isSpeaking = true;
        smileButton.classList.add('disabled'); 
        loadingSpinner.classList.add('visible');
        statusDisplay.classList.remove('initial-status');

        const payload = {
            contents: [{
                parts: [{ text: `Say cheerfully: ${text}` }] 
            }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: {
                    voiceConfig: {
                        prebuiltVoiceConfig: { voiceName: VOICE_NAME }
                    }
                }
            },
            model: "gemini-2.5-flash-preview-tts"
        };
        
        const apiUrl = `${API_URL_BASE}?key=${API_KEY}`;
        let response;
        let attempt = 0;
        const maxRetries = 3;

        // API 呼叫 (含指數退避)
        while (attempt < maxRetries) {
            try {
                response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (response.ok) { break; } 
                else if (response.status === 429 && attempt < maxRetries - 1) {
                    const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    attempt++;
                } else { throw new Error(`API 錯誤: ${response.statusText}`); }
            } catch (error) {
                if (attempt === maxRetries - 1) { throw error; }
                const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
                attempt++;
            }
        }
        
        if (!response || !response.ok) {
            throw new Error("未能從 Gemini API 獲得有效回應。");
        }

        const result = await response.json();
        const part = result?.candidates?.[0]?.content?.parts?.[0];
        const audioData = part?.inlineData?.data;
        const mimeType = part?.inlineData?.mimeType;

        if (!audioData || !mimeType || !mimeType.startsWith("audio/L16")) {
            throw new Error("API 回應中缺少或格式不正確的音訊數據。");
        }
        
        const rateMatch = mimeType.match(/rate=(\d+)/);
        if (!rateMatch) throw new Error("無法從 MIME Type 中提取取樣率。");
        const sampleRate = parseInt(rateMatch[1], 10);
        
        // --- [核心 iOS 播放優化區塊開始] ---
        try {
            // 1. PCM 數據處理
            const pcmData = base64ToArrayBuffer(audioData);
            const pcm16 = new Int16Array(pcmData);
            
            // 2. 轉換為 WAV Blob
            const wavBlob = pcmToWav(pcm16, sampleRate);
            
            // 3. **關鍵：等待 Blob 轉換為 ArrayBuffer (取代異步回呼)**
            const arrayBuffer = await blobToArrayBuffer(wavBlob); 
            
            // 4. **關鍵：在連續的 async 流程中解碼並播放**
            const audioBuffer = await activeAudioContext.decodeAudioData(arrayBuffer);
            
            const source = activeAudioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(activeAudioContext.destination);

            source.onended = () => {
                isSpeaking = false;
                smileButton.classList.remove('disabled');
                loadingSpinner.classList.remove('visible');
                
                statusTimeout = setTimeout(() => { 
                    statusDisplay.textContent = INITIAL_PHRASE;
                    statusDisplay.style.color = '#60a5fa'; 
                    statusDisplay.classList.add('initial-status'); 
                }, 7000); 
            };

            // 5. 啟動播放
            source.start(0);

        } catch (error) {
            console.error("Web Audio 播放流程失敗 (解碼或播放):", error);
            // 播放失敗，執行錯誤清理邏輯
            isSpeaking = false;
            smileButton.classList.remove('disabled');
            loadingSpinner.classList.remove('visible');
            statusDisplay.textContent = "播放失敗 (Web Audio 錯誤)";
            statusDisplay.style.color = '#f87171'; 
            statusTimeout = setTimeout(() => { 
                statusDisplay.textContent = INITIAL_PHRASE;
                statusDisplay.style.color = '#60a5fa'; 
                statusDisplay.classList.add('initial-status');
            }, 3000); 
        }
        // --- [核心 iOS 播放優化區塊結束] ---
    }


    // ========================================================================
    // Event Bindings
    // ========================================================================

    /**
     * Handles the click/touch event on the smiley button.
     */
    function handleSmileClick() {
        if (isSpeaking) {
             return;
        }
        
        // 1. 關鍵步驟：在使用者點擊事件的同步範圍內啟動 AudioContext
        const ctx = getAudioContext();
        if (!ctx) return; 

        // 2. 檢查狀態並強制恢復 (iOS Safari 必需)
        if (ctx.state === 'suspended') {
            // 必須在使用者互動中呼叫 resume()
            ctx.resume().then(() => {
                console.log("AudioContext 成功恢復。");
            }).catch(e => {
                console.error("AudioContext 恢復失敗:", e);
                // 如果恢復失敗，我們應該阻止後續的 speakText 執行
                if(statusDisplay.textContent !== CLICK_PHRASE) { // 避免覆蓋正在生成的文字
                    statusDisplay.textContent = "音訊啟動失敗，請再試一次。"; 
                    statusDisplay.style.color = '#f87171'; 
                }
            });
        }

        // 清除舊的狀態恢復計時器
        clearTimeout(statusTimeout);
        
        statusDisplay.classList.remove('initial-status');

        statusDisplay.textContent = "正在生成語音...";
        statusDisplay.style.color = '#fcd34d'; 
        
        // 快速顯示即將播放的文字
        setTimeout(() => {
            if(statusDisplay.textContent === "正在生成語音...") {
                statusDisplay.textContent = CLICK_PHRASE;
            }
        }, 300);

        // 傳入已啟動的 AudioContext，開始異步 API 流程
        speakText(CLICK_PHRASE, ctx)
            .then(() => {
                console.log("TTS 流程啟動成功。");
            })
            .catch(error => {
                console.error("TTS 總流程失敗:", error);
                // 錯誤處理：恢復狀態
                statusDisplay.textContent = "語音失敗 (API 錯誤)";
                statusDisplay.style.color = '#f87171'; 
                isSpeaking = false;
                smileButton.classList.remove('disabled');
                loadingSpinner.classList.remove('visible');
                
                statusTimeout = setTimeout(() => { 
                    statusDisplay.textContent = INITIAL_PHRASE;
                    statusDisplay.style.color = '#60a5fa'; 
                    statusDisplay.classList.add('initial-status'); 
                }, 3000); 
            });
        
    }

    // 核心動作：使用 click 事件
    smileButton.addEventListener('click', handleSmileClick); 

    // 視覺回饋：使用 pointerdown/up 處理按鈕的內凹視覺效果
    smileButton.addEventListener('pointerdown', (e) => {
        if (isSpeaking) return;
        e.preventDefault();
        smileButton.classList.add('active');
    });
    
    smileButton.addEventListener('pointerup', () => {
        smileButton.classList.remove('active');
    });
    
    smileButton.addEventListener('pointercancel', () => {
        smileButton.classList.remove('active');
    });


    // Initial state setup on page load
    window.onload = () => {
        statusDisplay.textContent = INITIAL_PHRASE;
        statusDisplay.style.color = '#60a5fa'; 
        statusDisplay.classList.add('initial-status'); 
        isSpeaking = false;
        smileButton.classList.remove('disabled');
        loadingSpinner.classList.remove('visible');
    };

</script>
</body>
</html>